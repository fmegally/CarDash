// generated by Fast Light User Interface Designer (fluid) version 1.0304

#include <FL/fl_draw.H>
#include <cmath>
#include <iostream>
#include "Gauge.h"
#include "util.h"

static
void drawCircle(double xc, double yc, double radius, double a1=0, double a2 = 360)
{
	fl_arc(xc - radius,
	       yc - radius,
	       2 * radius,
	       2 * radius,
	       a1,
	       a2);

	return;
}


static
void drawDisk(double xc, double yc, double radius, double a1=0, double a2 = 360)
{
	fl_pie(xc - radius,
	       yc - radius,
	       2 * radius,
	       2 * radius,
	       a1,
	       a2);

	return;
}

Gauge::Gauge(int x, int y, int size, double lower, double upper)
  : Fl_Widget(x, y, size, size, 0) {
	this->box(FL_FLAT_BOX);
	this->labeltype(FL_NO_LABEL);
	this->when(FL_WHEN_RELEASE);
	this->size = size;
	this->value = 0;
	this->valueMin = lower;
	this->valueMax = upper;
	this->angStart = 225.0;
	this->angEnd = -45.0;
		

	this->radius = 0.5 * size;

	this->XCent = size / 2;
	this->YCent = size / 2;
	this->majorTicks = range<double>(lower,upper,1,true);

	fl_font(FL_COURIER,16);	

	maxLabelRadius = 0;
	for (auto i: majorTicks)
	{
		char buff[10];
		int tw, th;
		sprintf(buff,"%.0f",i);
		fl_measure(buff,tw, th);
		double tR = 1.1 * sqrt(pow(0.5*tw,2) + pow(0.5*th,2));
		std::cout << buff << "," << tw << "," << th << "," << tR << std::endl;
		maxLabelRadius = tR > maxLabelRadius ? tR : maxLabelRadius;
	}
	std::cout << maxLabelRadius << std::endl;
	this->padding = 0;
	this->baseTickRadius = 0.5 * size - padding;
	this->majorTickRadius = 0.9 * baseTickRadius;
        this->minorTickRadius = 0.95 * baseTickRadius;
	this->needleRadius = 0.98 * majorTickRadius;
	this->labelMajorTicks = true;
	this->backgroundColor = 0x15151500;
	this->majorTickColor = 0x36F58000;
	//this->majorTickColor = 0xFFB00000;
	this->minorTickColor = 0x36F58000;
	//this->minorTickColor = 0xFFB00000;
	this->needleColor = 0xFFFFFF00;
	this->labelColor = 0xFFFF0000;
	return;
}

void Gauge::enableMajorLabels(void)
{
	labelMajorTicks = true;
	return;
}

void Gauge::disableMajorLabels(void)
{
	labelMajorTicks = false;
	return;
}

void Gauge::draw()
{
	int needlePivotSize = size / 8;
	
	//draw background
	fl_color(backgroundColor);
	drawDisk(x()+0.5*size,y()+0.5*size,baseTickRadius);

	//draw needle pivot
	fl_color(needleColor);
	fl_line_style(FL_SOLID,1);
	/*
	fl_pie( x() + XCent - (needlePivotSize / 2),
	        y() +YCent - (needlePivotSize / 2),
		needlePivotSize,
		needlePivotSize,
		0,
		360);
	*/

	//draw minor ticks
	fl_push_matrix();
	fl_color(minorTickColor);
	fl_translate(XCent, YCent);
	fl_translate(x(),y());
	fl_rotate(angStart);
	fl_line_style(FL_SOLID,1);

	for (int i = 0;i <= (majorTicks.size() - 1) * 10; i++)
	{
		fl_begin_line();
		fl_vertex(minorTickRadius,0);
		fl_vertex(baseTickRadius,0);
		fl_end_line();
		fl_rotate(-((angStart -  angEnd)/((majorTicks.size() - 1)*10)));
	}

	fl_pop_matrix();
	
	//draw major ticks and labels
	fl_font(FL_COURIER,16);	
	fl_line_style(FL_SOLID,2);

	fl_push_matrix();
	fl_color(majorTickColor);
	fl_translate(XCent, YCent);
	fl_translate(x(),y());
	fl_rotate(angStart);

	for (auto i: majorTicks)
	{
		if(labelMajorTicks)
		{
			char buff[10];
			int dx, dy;
			sprintf(buff,"%.0f",i);
			fl_measure(buff,dx, dy);
			double dR = 1.1* sqrt(pow(0.5*dx,2) + pow(0.5*dy,2));
			double a = map (i, valueMin, valueMax ,angStart ,angEnd)*(M_PI / 180);
			fl_draw(buff, x() + XCent+((majorTickRadius - dR)*cos(a))-(0.5 *dx), y() + YCent-((majorTickRadius - dR)*sin(a)) + (0.5 * dy));
		} else {
			majorTickRadius = 0.5 * (size - padding);
		}

		fl_begin_line();
			fl_vertex(majorTickRadius,0);
			fl_vertex(baseTickRadius,0);
		fl_end_line();
		fl_rotate(-((angStart -  angEnd)/(majorTicks.size()- 1)));
	}
	fl_pop_matrix();

	//draw needle
	fl_push_matrix();
	fl_color(needleColor);
	fl_translate(x(),y());
	fl_translate(XCent, YCent);

	double t = map(value,valueMin,valueMax,angStart,angEnd);
	fl_rotate(map(value,valueMin,valueMax,angStart,angEnd));

	fl_begin_polygon();
		fl_vertex(needleRadius, needleRadius * 0.01);
		fl_vertex(0.5 * needleRadius, needleRadius * 0.04);
		fl_vertex(0.5 * needleRadius,-needleRadius * 0.04) ;
		fl_vertex(needleRadius,-needleRadius * 0.01);
	fl_end_polygon();

	fl_pop_matrix();
}
