// generated by Fast Light User Interface Designer (fluid) version 1.0304

#include <FL/fl_draw.H>
#include <cmath>
#include <iostream>
#include "Gauge.h"
#include "util.h"

Gauge::Gauge(int x, int y, int size, double lower, double upper)
  : Fl_Widget(x, y, size, size, 0) {
	this->box(FL_FLAT_BOX);
	this->color(FL_BACKGROUND_COLOR);
	this->selection_color(FL_BACKGROUND_COLOR);
	this->labeltype(FL_NO_LABEL);
	this->when(FL_WHEN_RELEASE);
	this->size = size;
	this->value = 0;
	this->valueMin = lower;
	this->valueMax = upper;
	this->angStart = 225.0;
	this->angEnd = -45.0;
	this->radius = 0.5 * size;

	this->XCent = size / 2;
	this->YCent = size / 2;
	this->majorTicks = range<double>(lower,upper,1000.0,true);
	this->labelMajorTicks = true;
	return;
}

void Gauge::enableMajorLabels(void)
{
	labelMajorTicks = true;
	return;
}


void Gauge::disableMajorLabels(void)
{
	labelMajorTicks = false;
	return;
}


void Gauge::draw() {
	int needlePivotSize = size / 8;
	
	//draw background
	fl_color(FL_GRAY0);
	fl_pie(x(),y(),size,size,0,360);

	//draw needle pivot
	fl_color(0x50505000);
	fl_line_style(FL_SOLID,1);
	fl_pie( x() + XCent - (needlePivotSize / 2),
	        y() +YCent - (needlePivotSize / 2),
		needlePivotSize,
		needlePivotSize,
		0,
		360);
	
	//draw major ticks and labels
	fl_font(FL_COURIER,14);	
	fl_line_style(FL_SOLID,2);

	fl_push_matrix();
	fl_color(0xF0F00000);
	fl_translate(XCent, YCent);
	fl_translate(x(),y());
	fl_rotate(angStart);

	for (auto i: majorTicks)
	{
		if(labelMajorTicks)
		{
			char buff[10];
			int dx, dy;
			sprintf(buff,"%.0f",i);
			fl_measure(buff,dx, dy);
			double dR = 1.25 * sqrt(pow(0.5*dx,2) + pow(0.5*dy,2));
			double a = map (i, valueMin, valueMax ,angStart ,angEnd)*(M_PI / 180);
			double temp = (0.5 *size) - (2 * dR);
			radius = temp < radius ? temp : radius;
			//printf("dR = %.0f, a = %.4f, temp = %.0f, radius = %.0f\n",dR,a,temp,radius);
			fl_draw(buff, x() + XCent+((dR + radius)*cos(a))-(0.5 *dx), y() + YCent-((dR + radius)*sin(a)) + (0.5 * dy));
		} else {
			radius = 0.5 * size;
		}

		fl_begin_line();
			fl_vertex(0.9*radius,0);
			fl_vertex(0.98*radius,0);
		fl_end_line();
		fl_rotate(-((angStart -  angEnd)/(majorTicks.size()- 1)));
	}
	fl_pop_matrix();
	
	
	//draw minor ticks
	fl_push_matrix();
	fl_color(0xA0A00000);
	fl_translate(XCent, YCent);
	fl_translate(x(),y());
	fl_rotate(angStart);
	fl_line_style(FL_SOLID,1);

	for (int i = 0;i <= (majorTicks.size() - 1) * 10; i++)
	{
		fl_begin_line();
		fl_vertex(0.9*radius,0);
		fl_vertex(0.95*radius,0);
		fl_end_line();
		fl_rotate(-((angStart -  angEnd)/((majorTicks.size() - 1)*10)));
	}
	fl_pop_matrix();


	//draw needle
	fl_push_matrix();
	fl_color(FL_RED);
	fl_translate(x(),y());
	fl_translate(XCent, YCent);

	double t = map(value,valueMin,valueMax,angStart,angEnd);
	fl_rotate(map(value,valueMin,valueMax,angStart,angEnd));

	fl_begin_polygon();
		fl_vertex(radius * 0.85, radius * 0.005);
		fl_vertex(-0.08 * radius, radius * 0.03);
		fl_vertex(-0.08 * radius,-radius * 0.03) ;
		fl_vertex(radius * 0.85,-radius * 0.005);
	fl_end_polygon();

	fl_pop_matrix();
}
